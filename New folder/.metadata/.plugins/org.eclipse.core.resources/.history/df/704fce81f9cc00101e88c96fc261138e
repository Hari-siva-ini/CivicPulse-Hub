package com.example.backend.Controller;

import java.io.IOException;
import java.util.Map;
import java.util.HashMap;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;

import okhttp3.MediaType;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.RequestBody;
import okhttp3.Response;

@RestController
@RequestMapping("/api/chat")
@CrossOrigin(origins = "http://localhost:3000")
public class ChatController {

    private final OkHttpClient httpClient = new OkHttpClient();
    private final ObjectMapper objectMapper = new ObjectMapper();

    @Value("${gemini.api.key}")
    private String apiKey;

    // Optional override via properties
    @Value("${gemini.api.url:https://generativelanguage.googleapis.com/v1/models/gemini-pro:generateContent?key=}")
    private String apiUrlPrefix;

    private static final MediaType JSON = MediaType.get("application/json; charset=utf-8");

    @PostMapping("/ask")
    public ResponseEntity<?> askAI(@RequestBody Map<String, String> body) {
        String userMessage = body.get("message");
        if (userMessage == null || userMessage.trim().isEmpty()) {
            return ResponseEntity.badRequest().body(Map.of("error", "Message is required"));
        }

        // Construct JSON payload appropriate for the generative API
        // NOTE: adjust payload shape to match the exact API you use
        Map<String, Object> requestPayload = new HashMap<>();
        // Example payload expected by Google Generative API:
        requestPayload.put("temperature", 0.2);
        requestPayload.put("maxOutputTokens", 512);

        Map<String, Object> content = new HashMap<>();
        content.put("parts", new Object[] { Map.of("text", userMessage) });
        requestPayload.put("contents", new Object[] { content });

        try {
            String jsonRequest = objectMapper.writeValueAsString(requestPayload);
            RequestBody requestBody = RequestBody.create(jsonRequest, JSON);

            String url = apiUrlPrefix + apiKey;
            Request request = new Request.Builder()
                    .url(url)
                    .post(requestBody)
                    .addHeader("Accept", "application/json")
                    .build();

            try (Response response = httpClient.newCall(request).execute()) {
                if (!response.isSuccessful()) {
                    String respBody = response.body() != null ? response.body().string() : "";
                    return ResponseEntity.status(response.code())
                            .body(Map.of("error", "LLM provider error", "details", respBody));
                }

                String responseBody = response.body() != null ? response.body().string() : "{}";
                // return raw provider response if you want:
                // return ResponseEntity.ok(responseBody);

                // Parse provider response and extract readable text (example for Gemini-like response)
                JsonNode root = objectMapper.readTree(responseBody);

                // The exact path depends on provider. Common shapes:
                // Google Gemini: root.candidates[0].content.parts[0].text
                String replyText = "";

                // attempt multiple safe accesses
                if (root.has("candidates") && root.get("candidates").isArray()
                        && root.get("candidates").size() > 0) {
                    JsonNode cand = root.get("candidates").get(0);
                    if (cand.has("content")) {
                        JsonNode contentNode = cand.get("content");
                        if (contentNode.has("parts") && contentNode.get("parts").isArray()
                                && contentNode.get("parts").size() > 0) {
                            replyText = contentNode.get("parts").get(0).path("text").asText("");
                        }
                    }
                }

                // fallback: try other common fields
                if (replyText.isBlank() && root.has("output")) {
                    // some providers use output[0].content or similar
                    replyText = root.path("output").toString();
                }
                if (replyText.isBlank()) {
                    // last resort: return entire JSON as string
                    replyText = responseBody;
                }

                Map<String, Object> resp = new HashMap<>();
                resp.put("reply", replyText);
                resp.put("raw", root);
                return ResponseEntity.ok(resp);
            }
        } catch (IOException e) {
            e.printStackTrace();
            return ResponseEntity.status(500).body(Map.of("error", "Internal error", "details", e.getMessage()));
        }
    }
}
